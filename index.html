<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <title>englishBoost</title>

    <!-- Required Stylesheets -->
    <link type="text/css" rel="stylesheet" href="https://unpkg.com/bootstrap@next/dist/css/bootstrap.min.css"/>
    <link type="text/css" rel="stylesheet" href="https://unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.css"/>

    <!-- Required scripts -->
    <script src="https://unpkg.com/vue"></script>
    <script src="https://unpkg.com/babel-polyfill@latest/dist/polyfill.min.js"></script>
    <script src="https://unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.js"></script>
  </head>

<!-- https://bootstrap-vue.js.org/docs/components -->
  <body>
    <div id="app">
      <b-container fluid>
        <b-row>
	        <b-col>
	        	<h1>English Boost</h1>
		    	<!-- <p>Boost English learning with customized dictionaries</p> -->
                <b-form-group>
                    <b-button size="sm" variant="outline-secondary" @click="clearState">Clear storage</b-button>
                </b-form-group>
	        </b-col>
	    </b-row>

        <template v-if="exploreMode">
            <b-row>
                <b-col>
                    <b-button size="sm" variant="outline-secondary" @click="exploreBook(null)">Back</b-button>
                    <div class="float-right">
                        <b-check-group button-variant="outline-secondary" size="sm" buttons :options="sorts">
                    </div>
                </b-col>
            </b-row>
            <b-row>
                <b-col>
                    <b-pagination-nav align="center" base-url="#"
                      :number-of-pages="Math.ceil(currentBook.words.length/200)"
                      v-model="currentPage" />
                </b-col>
            </b-row>
            <b-row>
                <b-col v-for="(wordColumn, index) in currentBook.getPage(currentPage, 8)" :key="index">
                    <words :batch="wordColumn"></words>
                </b-col>
            </b-row>
            <b-row>
                <b-col>
                    <b-button size="sm" variant="outline-secondary" @click="exploreBook(null)">Back</b-button>
                </b-col>
            </b-row>
        </template>

        <b-row v-if="!exploreMode">
	        <b-col>
                <b-form-group>
    	        	<b-file accept="text/*" id="file_input" v-model="textFile"></b-file>
                </b-form-group>

                <b-card v-if="newBook">
                    <b-form-group>
                        <b-input v-model="newBook.title" placeholder="title"></b-input>
                        <b-input v-model="newBook.description" placeholder="description"></b-input>
                    </b-form-group>
                    <p class="card-text">Всего слов: {{ newBook.totalWordCount }}</p>
                    <p class="card-text">Уникальных:  {{ newBook.uniqCount }}</p>
                    <p class="card-text">Из них:</p>
                    <p class="card-text">Знаю - {{ newBook.counters.known }}</p>
                    <p class="card-text">Изучаю - {{ newBook.counters.learn }}</p>
                    <p class="card-text">Не знаю - {{ newBook.counters.unknown }}</p>
                    <p class="card-text">Новые (будут добавлены в "Не знаю") - {{ newBook.counters.new }}</p>
                    <p class="card-text">Стоп-слова - {{ newBook.counters.stopword }}</p>
                    <b-button size="sm" variant="outline-secondary" @click="addBook">Add to library</b-button>
                </b-card>
	        </b-col>

	        <b-col>
                <b>Library</b>
                <div v-for="book in books" v-if="!exploreMode">
                    <b-card :title="book.title + ' (' + book.words.length + ')'">
                        <p class="card-text">{{book.description}}</p>
                        <b-form-group>
                            <b-progress class="mt-1" show-value :max="book.words.length">
                                <b-progress-bar show-value :value="book.getUnknown()" variant="danger"></b-progress-bar>
                                <b-progress-bar show-value :value="book.getLearn()" variant="warning"></b-progress-bar>
                                <b-progress-bar show-value :value="book.getKnown()" variant="success"></b-progress-bar>
                            </b-progress>
                        </b-form-group>
                        <b-form-group>
                            <b-button size="sm" variant="outline-secondary" @click="exploreBook(book)">Explore</b-button>
                            <b-button size="sm" variant="outline-danger" @click="deleteBook(book)">Delete</b-button>
                        </b-form-group>
                    </b-card>
                </div>
            </b-col>

            <b-col>
                <b>Common dictionaries</b>
                <b-card  v-for="(dict, dictName) in dicts" :key="dictName" :title="dict.type + ' (' + dict.words.length + ')'">
                    <p class="card-text">{{dict.description}}</p>
                    <b-form-group>
                        <b-progress class="mt-1" show-value>
                            <b-progress-bar show-progress :value="100" :variant=dict.variant></b-progress-bar>
                        </b-progress>
                    </b-form-group>
                    <b-form-group>
                        <b-button size="sm" variant="outline-secondary" @click="exploreDict(dict)">Explore</b-button>
                    </b-form-group>
                </b-card>
	        </b-col>
	    </b-row>
      </b-container>
    </div>

    <script>

    function getStopWords() {
        return [
            // articles
            'a', 'an', 'the',
            // pronouns
            'all', 'another', 'any', 'anybody', 'anyone', 'anything', 'both',
            'each', 'other', 'either', 'everybody', 'everyone', 'everything',
            'few', 'he', 'her', 'hers', 'herself', 'him', 'himself', 'his',
            'i', 'it', 'its', 'itself', 'many', 'me', 'mine', 'more', 'most', 'much', 'my', 'myself',
            'neither', 'nobody', 'none', 'nothingone', 'other', 'others', 'our', 'ours' ,
            'ourselves', 'several', 'she', 'some', 'somebody', 'someone', 'something',
            'that', 'their', 'theirs', 'them', 'themselves', 'these', 'they', 'this', 'those',
            'us', 'we', 'what', 'whatever', 'which', 'whichever', 'who', 'whoever', 'whom',
            'whomever', 'whose', 'you', 'your', 'yours', 'yourself', 'yourselves',
            // preposition
            'aboard', 'about', 'above', 'across', 'after', 'against', 'along',
            'amid', 'among', 'anti', 'around', 'asat', 'before',
            'behind', 'below', 'beneath', 'beside', 'besides', 'between', 'beyond', 'but', 'by',
            'concerning', 'considering', 'despite', 'down', 'during',
            'except', 'excepting', 'excluding',
            'following', 'for', 'from', 'in', 'inside', 'into', 'like',
            'minus', 'near', 'of', 'off', 'on', 'onto', 'opposite', 'outside', 'over',
            'past', 'per', 'plus', 'regarding', 'round', 'save', 'since', 'than',
            'through', 'to', 'toward', 'towards',
            'under', 'underneath', 'unlike', 'until', 'up', 'upon',
            'versus', 'via', 'with', 'within', 'without',
            // conjunction
            'and', 'that', 'but', 'or', 'as', 'if', 'when', 'than', 'because',
            'while', 'where', 'after', 'so', 'though', 'since', 'until',
            'whether', 'before', 'although', 'nor', 'like', 'once',
            'unless', 'now', 'except'
        ];
    }

    function loadBooks() {
        var booksSerialized = JSON.parse(localStorage.getItem('books'));
        if (!booksSerialized) {
            return;
        }
        var books = [];
        for (var i = 0; i < booksSerialized.length; i++) {
            var book = new Book(null, booksSerialized[i].title, booksSerialized[i].description);
            // book.phrases = booksSerialized[i].phrases;
            book.totalWordCount = booksSerialized[i].totalWordCount;
            book.words = booksSerialized[i].words;
            book.pareto = booksSerialized[i].pareto;
            book.paretoLimit = booksSerialized[i].paretoLimit;
            books.push(book);
        }
        return books;
    }
    function loadDicts() {
        return JSON.parse(localStorage.getItem('dicts'));
    }

    function Dictionary(words, type, variant, description) {
        this.words = words;
        this.type = type;
        this.variant = variant;
        this.description = description;
    }

    function Book(text, title, description) {
        // this.phrases = [];
        this.totalWordCount = 0;
        this.words = [];
        this.pareto = [];
        this.paretoLimit = 0.8;
        this.title = title;
        this.description = description;

        // используется только в процессе добавления книги, можно не сохранять
        this.counters = null;
        this.uniqCount = 0;

        this.getUnknown = function() {
            return this.words.filter(function(word){
                return word[2] == 'unknown';
            }).length;
        }
        this.getLearn = function() {
            return this.words.filter(function(word){
                return word[2] == 'learn';
            }).length;
        }
        this.getKnown = function() {
            return this.words.filter(function(word){
                return word[2] == 'known';
            }).length;
        }

        this.objectSort = function(obj) {
            var sortable = [];
            for (var property in obj) {
                sortable.push([property, obj[property]]);
            }
            sortable.sort(function(a, b) {
                return b[1] - a[1];
            });
            return sortable;
        }

        this.getPage = function(page, columnCount) {
            var wordsInPage = Math.ceil(this.words.length / page) * 200;
            var page = this.words.slice((page-1)*200, page*200);

            var wordsInColumn = Math.ceil(page.length / (columnCount));

            var batches = [];
            var batch = [];
            for (var i = 0; i < page.length; i++) {
                batch.push(page[i]);
                if ((i+1) % wordsInColumn == 0) {
                    batches.push(batch);
                    batch = [];
                }
            }
            batches.push(batch);
            return batches;
        }

        this.calcPareto = function() {
            var acc = 0;
            for (var i = 0; i < this.words.length; i++) {
                this.pareto.push(this.words[i][0]);
                acc += this.words[i][1];
                if (acc > this.words.length * this.paretoLimit) {
                    break;
                }
            }
        }

        if (!text) {
            return null;
        }

        // this.phrases = text.split(/[.!?]/).filter(function(phrase){
        //     return phrase.length > 0;
        // });

        var words = text.split(/(\s+)/);
        for (var i = 0; i < words.length - 1; i++) {
            words[i] += " ";
        }
        this.totalWordCount = words.length;

        words = words.map(function(word){
            // left+right smart trim
            return word.toLowerCase().replace(/^\W+/, '').replace(/\W+$/, '');
        }).filter(function(word){
            return word.length > 0;
        });

        var uniqWords = {};
        for (var i = 0; i < words.length; i++) {
            var word = words[i];
            if (uniqWords.hasOwnProperty(word) ) {
                uniqWords[word]++;
            } else {
                uniqWords[word] = 1;
            }
        }
        this.words = this.objectSort(uniqWords);
        this.uniqCount = this.words.length;
    }

    Vue.component('words', {
        props: ['batch'],
        data: function() {
            return {
                unknown: {backgroundColor: '#ffffff'},
                learn: {backgroundColor: '#ffc107'},
                known: {backgroundColor: '#28a745'},
            }
        },
        template: '\
            <div>\
                <div v-for="word in batch">\
                    <p :state="word[2]" :style="styleSelect(word)" @click="toggle">{{ word[0] }}</p>\
                </div>\
            </div>',
        methods: {
            styleSelect: function(word) {
                return this[word[2]];
            },
            toggle: function(event) {
                var word = event.target.textContent;
                var state = event.target.attributes.state.nodeValue;

                var newState = null;
                if (state == 'unknown') {
                    newState = 'learn';
                }
                if (state == 'learn') {
                    newState = 'known';
                }
                if (state == 'known') {
                    newState = 'unknown';
                }

                event.target.attributes.state.nodeValue = newState;
                event.target.style = 'background-color: ' + this[newState].backgroundColor;

                this.$root.$emit('toggleStateWord', {word: word, oldState:state, newState: newState});
            }
        }
    });

    window.app = new Vue({
        el: "#app",
        data: {
			textFile: null, // File object
			text: null,
            newBook: null,

            books: loadBooks() || [],

            dicts: loadDicts() || {
                unknown:  new Dictionary([], 'unknown', 'danger', 'Что не знаю'),
                learn:    new Dictionary([], 'learn', 'warning',  'Что изучить'),
                known:    new Dictionary([], 'known', 'success',  'Что знаю'),
                stopword: new Dictionary(getStopWords(), 'stopwords', 'info', 'Частовстречаемые общие слова'),
            },

            currentBook: null,
            exploreMode: false,
            currentPage: 1,

            sorts: [
                { text: 'Sort by frequency', value: 1 },
                { text: 'Sort by alphabet', value: 2 },
                { text: 'Sort by type', value: 3 },
            ]
        },
        watch: {
			textFile: function() {
				if (this.textFile) {
					var reader = new FileReader();
					reader.onload = function() {
						app.text = reader.result;
						app.newBook = new Book(app.text, app.textFile.name);

                        // фильтруем стоп-слова
                        var countStopword = 0;
                        app.newBook.words = app.newBook.words.filter(function(word){
                            if (app.dicts.stopword.words.indexOf(word[0]) !== -1) {
                                countStopword++;
                                return false;
                            }
                            return true;
                        });

                        // считаем pareto
                        app.newBook.calcPareto();

                        // находим слова, которые уже есть в словарях и проставляем им type
                        var counters = {
                            new: 0,
                            unknown: 0,
                            learn: 0,
                            known: 0,
                            stopword: countStopword
                        };
                        for (var i = 0; i < app.newBook.words.length; i++) {
                            var word = app.newBook.words[i][0];

                            // временный тип 'new', при добавлении будет заменён на unknown
                            var type = 'new';
                            if (app.dicts.unknown.words.indexOf(word) !== -1) {
                                type = 'unknown';
                                counters.unknown++;
                            }
                            if(app.dicts.learn.words.indexOf(word) !== -1) {
                                type = 'learn';
                                counters.learn++;
                            }
                            if(app.dicts.known.words.indexOf(word) !== -1) {
                                type = 'known';
                                counters.known++;
                            }
                            if (type == 'new') {
                                counters.new++;
                            }
                            app.newBook.words[i][2] = type;
                            app.newBook.counters = counters;
                        }
					};
					reader.readAsText(app.textFile);
				}
			},
        },
        methods: {
            saveBooksAndDicts: function(books, dicts) {
                var booksSerialized = [];
                for (var i = 0; i < books.length; i++) {
                    booksSerialized.push({
                        // phrases:        books[i].phrases,
                        totalWordCount: books[i].totalWordCount,
                        words:          books[i].words,
                        pareto:         books[i].pareto,
                        paretoLimit:    books[i].paretoLimit,
                        title:          books[i].title,
                        description:    books[i].description,
                    });
                }
                try {
                    localStorage.setItem('books', JSON.stringify(booksSerialized))
                    localStorage.setItem('dicts', JSON.stringify(dicts))
                } catch (e) {
                    if (e == QUOTA_EXCEEDED_ERR) {
                        alert('localStorage overflow');
                    }
                }
            },
            clearState: function() {
                localStorage.clear();
                alert('localStorage clear');
            },
            addBook: function(event) {
                this.books.push(this.newBook);

                // раскидываем слова по словарям в соотвествии с их типами
                for (var i = 0; i < this.newBook.words.length; i++) {
                    var wordInfo = this.newBook.words[i];
                    if (wordInfo[2] == 'new') {
                        wordInfo[2] = 'unknown';
                    }

                    // добавляем в словарь, если слова там ещё нет
                    if(app.dicts[wordInfo[2]].words.indexOf(wordInfo[0]) == -1) {
                        this.dicts[wordInfo[2]].words.push(wordInfo[0]);
                    }
                }

                this.newBook = null;

                this.saveBooksAndDicts(this.books, this.dicts);
            },
            deleteBook: function(book) {
                this.books = this.books.filter(function(item) {
                    return item.title != book.title;
                });
                this.saveBooksAndDicts(this.books, this.dicts);
            },
            exploreBook: function(book) {
                this.currentBook = book;
                this.exploreMode = !this.exploreMode;
            },
            exploreDict: function(dict) {
                alert("TODO");
            },
        },
        mounted: function () {
            this.$root.$on('toggleStateWord', function (data) {

                // перемещаем слово в новый словарь
                this.dicts[data.oldState].words = this.dicts[data.oldState].words.filter(function(word){
                    return word != data.word;
                });
                this.dicts[data.newState].words.push(data.word);

                // в книгах state слова тоже должен меняться
                for (var i = 0; i < this.books.length; i++) {
                    var book = this.books[i];
                    for (var j = 0; j < book.words.length; j++) {
                        var word = book.words[j];
                        if (word[0] == data.word) {
                            this.books[i].words[j][2] = data.newState;
                        }
                    }
                }

                this.saveBooksAndDicts(this.books, this.dicts);
            });
        }
    });
    </script>

  </body>
</html>